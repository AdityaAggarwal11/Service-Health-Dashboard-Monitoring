<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Service Health Dashboard</title>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <link rel="stylesheet" href="style.css" />
</head>
<body>

  <header>
    <h2>Service Health Dashboard</h2>
    <button class="toggle-darkmode" onclick="toggleDarkMode()">Toggle Dark Mode</button>
  </header>

  <div id="alerts"></div>

  <div class="charts">
    <div class="chart-card">
      <canvas id="cpuChart"></canvas>
      <div class="status" id="cpuStatus">Status: 游릭</div>
    </div>
    <div class="chart-card">
      <canvas id="ramChart"></canvas>
      <div class="status" id="ramStatus">Status: 游릭</div>
    </div>
    <div class="chart-card">
      <canvas id="diskChart"></canvas>
      <div class="status" id="diskStatus">Status: 游릭</div>
    </div>
  </div>

  <p id="lastUpdated">Last Updated: -</p>

  <script>
    const cpuCtx = document.getElementById('cpuChart').getContext('2d');
    const ramCtx = document.getElementById('ramChart').getContext('2d');
    const diskCtx = document.getElementById('diskChart').getContext('2d');

    let lastUpdateTimestamp = null; // To store last metrics fetch time (Date object)

    function getStatusIcon(percent, thresholds) {
      if (percent > thresholds.red) return '游댮';
      if (percent > thresholds.yellow) return '游리';
      return '游릭';
    }

    function getColorSet(percent, thresholds, colors) {
      if (percent > thresholds.red) return [colors.red, '#ccc'];
      if (percent > thresholds.yellow) return [colors.yellow, '#ccc'];
      return [colors.green, '#ccc'];
    }

    const cpuChart = new Chart(cpuCtx, {
      type: 'doughnut',
      data: {
        labels: ['Used %', 'Free %'],
        datasets: [{
          data: [0, 100],
          backgroundColor: ['#4CAF50', '#ccc'],
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'CPU Usage (%)',
            font: { size: 18 }
          },
          legend: { position: 'bottom' }
        },
        cutout: '70%'
      }
    });

    const ramChart = new Chart(ramCtx, {
      type: 'doughnut',
      data: {
        labels: ['Used %', 'Free %'],
        datasets: [{
          data: [0, 100],
          backgroundColor: ['#4CAF50', '#ccc'],
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'RAM Usage (%)',
            font: { size: 18 }
          },
          legend: { position: 'bottom' }
        },
        cutout: '70%'
      }
    });

    const diskChart = new Chart(diskCtx, {
      type: 'doughnut',
      data: {
        labels: ['Used %', 'Free %'],
        datasets: [{
          data: [0, 100],
          backgroundColor: ['#4CAF50', '#ccc'],
        }]
      },
      options: {
        responsive: true,
        plugins: {
          title: {
            display: true,
            text: 'Disk Usage (%)',
            font: { size: 18 }
          },
          legend: { position: 'bottom' }
        },
        cutout: '70%'
      }
    });

    // Format a date to IST string (YYYY-MM-DD HH:mm:ss IST)
    function formatDateIST(date) {
      const utc = date.getTime() + (date.getTimezoneOffset() * 60000);
      const istOffset = 5.5 * 60 * 60000;
      const istTime = new Date(utc + istOffset);

      const year = istTime.getFullYear();
      const month = String(istTime.getMonth() + 1).padStart(2, '0');
      const day = String(istTime.getDate()).padStart(2, '0');
      const hours = String(istTime.getHours()).padStart(2, '0');
      const minutes = String(istTime.getMinutes()).padStart(2, '0');
      const seconds = String(istTime.getSeconds()).padStart(2, '0');

      return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} IST`;
    }

    // Convert timestamp to relative time string like "5 secs ago", "1 min ago"
    function relativeTimeFromNow(pastDate) {
      if (!pastDate) return '-';

      const now = new Date();
      let diff = Math.floor((now - pastDate) / 1000); // difference in seconds

      if (diff < 0) return 'just now';

      if (diff < 5) return 'just now';
      if (diff < 60) return `${diff} second${diff === 1 ? '' : 's'} ago`;
      if (diff < 3600) {
        const mins = Math.floor(diff / 60);
        return `${mins} minute${mins === 1 ? '' : 's'} ago`;
      }
      if (diff < 86400) {
        const hrs = Math.floor(diff / 3600);
        return `${hrs} hour${hrs === 1 ? '' : 's'} ago`;
      }
      // For days or more, just show date:
      return formatDateIST(pastDate);
    }

    // Update the last updated paragraph with relative time
    function updateLastUpdatedRelative() {
      const relative = relativeTimeFromNow(lastUpdateTimestamp);
      document.getElementById('lastUpdated').innerText = `Last Updated: ${relative}`;
    }

    async function updateMetrics() {
      try {
        const response = await fetch('/metrics');
        const data = await response.json();

        const thresholds = {
          cpu: { yellow: 60, red: 85 },
          ram: { yellow: 60, red: 85 },
          disk: { yellow: 70, red: 90 }
        };

        const colors = {
          green: '#4CAF50',
          yellow: '#FFC107',
          red: '#F44336'
        };

        // CPU
        cpuChart.data.datasets[0].data = [data.cpu_percent, 100 - data.cpu_percent];
        cpuChart.data.datasets[0].backgroundColor = getColorSet(data.cpu_percent, thresholds.cpu, colors);
        document.getElementById('cpuStatus').textContent = `Status: ${getStatusIcon(data.cpu_percent, thresholds.cpu)}`;
        cpuChart.update();

        // RAM
        ramChart.data.datasets[0].data = [data.ram_percent, 100 - data.ram_percent];
        ramChart.data.datasets[0].backgroundColor = getColorSet(data.ram_percent, thresholds.ram, colors);
        document.getElementById('ramStatus').textContent = `Status: ${getStatusIcon(data.ram_percent, thresholds.ram)}`;
        ramChart.update();

        // Disk
        diskChart.data.datasets[0].data = [data.disk_percent, 100 - data.disk_percent];
        diskChart.data.datasets[0].backgroundColor = getColorSet(data.disk_percent, thresholds.disk, colors);
        document.getElementById('diskStatus').textContent = `Status: ${getStatusIcon(data.disk_percent, thresholds.disk)}`;
        diskChart.update();

        // Save the last update time to now
        lastUpdateTimestamp = new Date();

        // Update relative time display immediately
        updateLastUpdatedRelative();

      } catch (err) {
        console.error('Error updating metrics:', err);
      }
    }

    async function updateAlerts() {
      try {
        const response = await fetch('/alerts');
        const data = await response.json();
        const alertBox = document.getElementById('alerts');
        alertBox.innerHTML = '';

        if (data.alerts.length > 0) {
          data.alerts.forEach(alert => {
            const div = document.createElement('div');
            div.textContent = `丘멆잺 ${alert}`;
            alertBox.appendChild(div);
          });
          alertBox.style.display = 'block';
        } else {
          alertBox.style.display = 'none';
        }
      } catch (err) {
        console.error('Error fetching alerts:', err);
      }
    }

    function toggleDarkMode() {
      document.body.classList.toggle('dark');
    }

    // Initial load
    updateMetrics();
    updateAlerts();

    // Update metrics and alerts every 5 seconds
    setInterval(updateMetrics, 5000);
    setInterval(updateAlerts, 5000);

    // Update the relative time every second
    setInterval(updateLastUpdatedRelative, 1000);
  </script>
</body>
</html>

